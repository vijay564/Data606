}else
{
print("Invalid Input")
}
return(inverse)
}
(A <- matrix(c(1,2,0,3,0,4,5,0,6), 3,3))
(B<- myinverse(A))
round(I<- A%*%B,0)
else
#CREATING FUNCTION WITH ARGUMENT
myinverse <- function(V){
#CHECK FOR SQUARE MATRIX AND DETERMINENT NOT EQUAL TO ZERO
if(is.matrix(V) & nrow(V) == ncol(V) & det(V) != 0){
print("CalCULATING INVERSE OF MATRIX")
#CALCULATING DETERMINENT OF THE MATRIX
detV <- det(V)
#DEFINING NULL MATRIX
C <- matrix(0, nrow = nrow(V), ncol = ncol(V))
#USING FOR LOOP TO CALCULATE COFACTOR MATRIX
for(i in 1:nrow(V)){
for(j in 1:ncol(V)){
C[i,j] = (-1)^(i+j)*det(V[-i,-j])
}
}
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#IF STATEMENT FAILS IT WILL EXECUTE ELSE STATEMENT
}
else
{
print("Invalid Input")
}
return(inverse)
}
(A <- matrix(c(1,2,0,3,0,4,5,0,6), 3,3))
(B<- myinverse(A))
I<- A%*%B
(I<- A%*%B)
round(I,0)
round(I,2)
(I<- A%*%B)
round(I,2)
#CREATING FUNCTION WITH ARGUMENT
myinverse <- function(V){
#CHECK FOR SQUARE MATRIX AND DETERMINENT NOT EQUAL TO ZERO
if(is.matrix(V) & nrow(V) == ncol(V) & det(V) != 0){
print("CalCULATING INVERSE OF MATRIX")
#CALCULATING DETERMINENT OF THE MATRIX
detV <- det(V)
#DEFINING NULL MATRIX
C <- matrix(0, nrow = nrow(V), ncol = ncol(V))
#USING FOR LOOP TO CALCULATE COFACTOR MATRIX
for(i in 1:nrow(V)){
for(j in 1:ncol(V)){
C[i,j] = (-1)^(i+j)*det(V[-i,-j])
}
}
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#IF STATEMENT FAILS IT WILL EXECUTE ELSE STATEMENT
}
else
{
print("Invalid Input")
}
return(inverse)
}
#DEFINING MATRIX A
(A <- matrix(c(1,2,0,3,0,4,5,0,6), 3,3))
#CALLING FUNCTION BY IT'S NAME
(B<- myinverse(A))
# CHECK FOR "A×B = I"
(I<- A%*%B)
round(I)
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#CREATING FUNCTION WITH ARGUMENT
myinverse <- function(V){
#CHECK FOR SQUARE MATRIX AND DETERMINENT NOT EQUAL TO ZERO
if(is.matrix(V) & nrow(V) == ncol(V) & det(V) != 0){
print("CalCULATING INVERSE OF MATRIX")
#CALCULATING DETERMINENT OF THE MATRIX
detV <- det(V)
#DEFINING NULL MATRIX
C <- matrix(0, nrow = nrow(V), ncol = ncol(V))
#USING FOR LOOP TO CALCULATE COFACTOR MATRIX
for(i in 1:nrow(V)){
for(j in 1:ncol(V)){
C[i,j] = (-1)^(i+j)*det(V[-i,-j])
}
}
#CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
#IF STATEMENT FAILS IT WILL EXECUTE ELSE STATEMENT
}
else
{
print("Invalid Input")
}
return(inverse)
}
#DEFINING MATRIX A
(A <- matrix(c(1,2,0,3,0,4,5,0,6), 3,3))
#CALLING FUNCTION BY IT'S NAME
(B<- myinverse(A))
# CHECK FOR "A×B = I"
(I<- A%*%B)
round(I)
# CREATING FUNCTION WITH ARGUMENT
myinverse <- function(V){
# CHECK FOR SQUARE MATRIX AND DETERMINENT NOT EQUAL TO ZERO
if(is.matrix(V) & nrow(V) == ncol(V) & det(V) != 0){
print("CalCULATING INVERSE OF MATRIX")
# CALCULATING DETERMINENT OF THE MATRIX
detV <- det(V)
# DEFINING NULL MATRIX
C <- matrix(0, nrow = nrow(V), ncol = ncol(V))
# USING FOR LOOP TO CALCULATE COFACTOR MATRIX
for(i in 1:nrow(V)){
for(j in 1:ncol(V)){
C[i,j] = (-1)^(i+j)*det(V[-i,-j])
}
}
# CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
# IF STATEMENT FAILS IT WILL EXECUTE ELSE STATEMENT
}
else
{
print("Invalid Input")
}
}
# DEFINING MATRIX A
(A <- matrix(c(1,2,0,3,0,4,5,0,6), 3,3))
# CALLING FUNCTION BY IT'S NAME
(B<- myinverse(A))
# CHECK FOR "A×B = I"
(I<- A%*%B)
A<- matrix(c(1, -1, 2, 0, 3, 4), 2,3)
A<- matrix(c(1, -1, 2, 0, 3, 4), 2,3)
(X <-(A)%*%t(A))
(Y<- t(A)%*%(A))
# COMPUTING EIGEN VALUES AND EIGEN VECTORS OF 'X' AND 'Y' :
(E_X <- eigen(X))
(E_Y<- eigen(Y))
# COMPUTE LEFT SINGULAR, SINGULAR, RIGHT SINGULAR OF 'A' USING "SVD" FUNCTION :
(left_singular_A <- svd(A)$u)
(singular_A <- svd(A)$d)
(right_singular_A <- svd(A)$v)
# CREATING FUNCTION WITH ARGUMENT
myinverse <- function(V){
# CHECK FOR SQUARE MATRIX AND DETERMINENT NOT EQUAL TO ZERO
if(is.matrix(V) & nrow(V) == ncol(V) & det(V) != 0){
print("INVERSE OF MATRIX")
# CALCULATING DETERMINENT OF THE MATRIX
detV <- det(V)
# DEFINING NULL MATRIX
C <- matrix(0, nrow = nrow(V), ncol = ncol(V))
# USING FOR LOOP TO CALCULATE COFACTOR MATRIX
for(i in 1:nrow(V)){
for(j in 1:ncol(V)){
C[i,j] = (-1)^(i+j)*det(V[-i,-j])
}
}
# CALCULATING INVERSE BY THE FORMULAE
inverse = t(C)/detV
# IF STATEMENT FAILS IT WILL EXECUTE ELSE STATEMENT
}
else
{
print("Invalid Input")
}
}
# DEFINING MATRIX A
(A <- matrix(c(1,2,0,3,0,4,5,0,6), 3,3))
# CALLING FUNCTION BY IT'S NAME
(B<- myinverse(A))
# CHECK FOR "A×B = I"
(I<- A%*%B)
round(I)
exp(-5)
(lambda <- 10000/2000)
exp(-5)
knitr::opts_chunk$set(echo = TRUE)
library(matrixcalc)
markov <- function(u, P, n){
matrixPower <- matrix.power(P, n)
result <- u %*%matrixPower
return(result)
}
u <- c(1/3, 1/3, 1/3)
oz <- c(.5, .25, .25, .5,  0, .5, .25, .25, .5)
P <- matrix(oz, nrow = 3, ncol = 3, byrow = T)
markov(u, P, 10)
knitr::opts_chunk$set(echo = TRUE)
# For user-freindliness we'll pull major, number employed, number unemployed.
# for all ages
all_age_contin <- all_ages_df %>% dplyr::select(Major, Employed, Unemployed)
# For user-freindliness we'll pull major, number employed, number unemployed.
# for all ages
all_age_contin <- all_ages_df %>% dplyr::select(Major, Employed, Unemployed)
setwd("E:/github/MS/DATA606/Data606")
library(tidyr)
library(dplyr)
library(psych)
library(stringr)
library(ggplot2)
library(MASS)
all_ages_df <-  read.csv(file ="https://raw.githubusercontent.com/fivethirtyeight/data/master/college-majors/all-ages.csv", header= TRUE)
names(all_ages_df)
all_ages_df_eng <- all_ages_df %>% filter(Major_category == "Engineering")
head(all_ages_df_eng)
grad_df <-  read.csv(file = "https://raw.githubusercontent.com/fivethirtyeight/data/master/college-majors/grad-students.csv", header= TRUE)
names(grad_df)
grad_df_eng <- grad_df %>% filter(Major_category == "Engineering")
head(grad_df_eng)
recent_grad_df <-  read.csv(file = "https://raw.githubusercontent.com/fivethirtyeight/data/master/college-majors/recent-grads.csv", header= TRUE)
names(recent_grad_df)
recent_grad_df_eng <- recent_grad_df %>% filter(Major_category == "Engineering")
head(recent_grad_df_eng)
summary(all_ages_df$Unemployment_rate)
summary(grad_df$Grad_unemployment_rate)
summary(recent_grad_df$Unemployment_rate)
# Box plot
unempl <- cbind(all_ages_df$Unemployment_rate, recent_grad_df$Unemployment_rate, grad_df$Grad_unemployment_rate)
boxplot(unempl,names = c("All", "Recent Grad", "Grad Student"), ylab = "Unemployment Rate")
#Bar plot
unempl <- cbind(all_ages_df$Unemployment_rate, recent_grad_df$Unemployment_rate, grad_df$Grad_unemployment_rate)
barplot(unempl/nrow(unempl), names.arg = c("All", "Recent Grad", "Grad Student"), xlab = "Unemployment Rate", col = rainbow(nrow(unempl)))
summary(all_ages_df$Median)
summary(grad_df$Grad_median)
summary(recent_grad_df$Median)
# Box plot
medsal <- cbind(all_ages_df$Median, recent_grad_df$Median, grad_df$Grad_median)
boxplot(medsal, names = c("All", "Recent Grad", "Grad Student"), ylab = "Median Salary USD")
#Barplot
income <- cbind(all_ages_df$Median, recent_grad_df$Median, grad_df$Grad_median)
barplot(income/nrow(income), names.arg = c("All", "Recent Grad", "Grad Student"), xlab = "income", col = rainbow(nrow(income)))
# For user-freindliness we'll pull major, number employed, number unemployed.
# for all ages
all_age_contin <- all_ages_df %>% dplyr::select(Major, Employed, Unemployed)
head(all_age_contin)
chisq.test(all_age_contin[,-1])
# for all grad
grd_st_contin <- grad_stdnt %>% dplyr::select(Major, Grad_employed, Grad_unemployed)
# For user-freindliness we'll pull major, number employed, number unemployed.
# for all ages
all_age_contin <- all_ages_df %>% dplyr::select(Major, Employed, Unemployed)
head(all_age_contin)
chisq.test(all_age_contin[,-1])
# for all grad
grd_st_contin <- grad_stdn %>% dplyr::select(Major, Grad_employed, Grad_unemployed)
# For user-freindliness we'll pull major, number employed, number unemployed.
# for all ages
all_age_contin <- all_ages_df %>% dplyr::select(Major, Employed, Unemployed)
head(all_age_contin)
chisq.test(all_age_contin[,-1])
# for all grad
grd_st_contin <- grad %>% dplyr::select(Major, Grad_employed, Grad_unemployed)
# For user-freindliness we'll pull major, number employed, number unemployed.
# for all ages
all_age_contin <- all_ages_df %>% dplyr::select(Major, Employed, Unemployed)
head(all_age_contin)
chisq.test(all_age_contin[,-1])
# for all grad
grd_st_contin <- grad_df %>% dplyr::select(Major, Grad_employed, Grad_unemployed)
head(grd_st_contin)
chisq.test(grd_st_contin[,-1])
#for all recent grad
rct_gr_contin <- recent_grad_df %>% dplyr::select(Major,Employed,Unemployed) %>% filter(Major != "MILITARY TECHNOLOGIES" )
head(rct_gr_contin)
chisq.test(rct_gr_contin[,-1])
# LINEAR MODEL for all ages
model1 <- lm(all_ages_df$Median ~ all_ages_df$Unemployment_rate)
summary(model1)
# Plot
ggplot(all_ages_df, aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# Residual plot
ggplot(model1, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model1))
qqline(resid(model1))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m1 <- boxcox(model1)
# LINEAR MODEL for all ages
model1 <- lm(all_ages_df$Median ~ all_ages_df$Unemployment_rate)
summary(model1)
# Plot
ggplot(all_ages_df, aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# Residual plot
ggplot(model1, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model1))
qqline(resid(model1))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m1 <- boxcox(model1)
myt_df <- as.data.frame(myt)
# LINEAR MODEL for all ages
model1 <- lm(all_ages_df$Median ~ all_ages_df$Unemployment_rate)
summary(model1)
# Plot
ggplot(all_ages_df, aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# Residual plot
ggplot(model1, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model1))
qqline(resid(model1))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m1 <- boxcox(model1)
m1_df <- as.data.frame(m1)
(optimal_lambda <- m1_df[which.max(m1$y),1])
model2 <- lm(all_ages$Median^optimal_lambda ~ all_ages$Unemployment_rate)
# LINEAR MODEL for all ages
model1 <- lm(all_ages_df$Median ~ all_ages_df$Unemployment_rate)
summary(model1)
# Plot
ggplot(all_ages_df, aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# Residual plot
ggplot(model1, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model1))
qqline(resid(model1))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m1 <- boxcox(model1)
m1_df <- as.data.frame(m1)
(optimal_lambda <- m1_df[which.max(m1$y),1])
model2 <- lm(all_ages_df$Median^optimal_lambda ~ all_ages$Unemployment_rate)
# LINEAR MODEL for all ages
model1 <- lm(all_ages_df$Median ~ all_ages_df$Unemployment_rate)
summary(model1)
# Plot
ggplot(all_ages_df, aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# Residual plot
ggplot(model1, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model1))
qqline(resid(model1))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m1 <- boxcox(model1)
m1_df <- as.data.frame(m1)
(optimal_lambda <- m1_df[which.max(m1$y),1])
model2 <- lm(all_ages_df$Median^optimal_lambda ~ all_ages_df$Unemployment_rate)
summary(model2)
# Plot
ggplot(all_ages_df$Median^optimal_lambda , aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# LINEAR MODEL for all ages
model1 <- lm(all_ages_df$Median ~ all_ages_df$Unemployment_rate)
summary(model1)
# Plot
ggplot(all_ages_df, aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# Residual plot
ggplot(model1, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model1))
qqline(resid(model1))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m1 <- boxcox(model1)
m1_df <- as.data.frame(m1)
(optimal_lambda <- m1_df[which.max(m1$y),1])
model2 <- lm(all_ages_df$Median^optimal_lambda ~ all_ages_df$Unemployment_rate)
summary(model2)
# Plot
ggplot(model2 , aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# For user-freindliness we'll pull major, number employed, number unemployed.
# for all ages
all_age_contin <- all_ages_df %>% dplyr::select(Major, Employed, Unemployed)
head(all_age_contin)
chisq.test(all_age_contin[,-1])
# for all grad
grd_st_contin <- grad_df %>% dplyr::select(Major, Grad_employed, Grad_unemployed)
head(grd_st_contin)
chisq.test(grd_st_contin[,-1])
#for all recent grad
rct_gr_contin <- recent_grad_df %>% dplyr::select(Major,Employed,Unemployed) %>% filter(Major != "MILITARY TECHNOLOGIES" )
head(rct_gr_contin)
chisq.test(rct_gr_contin[,-1])
summary(all_ages_df$Unemployment_rate)
summary(grad_df$Grad_unemployment_rate)
summary(recent_grad_df$Unemployment_rate)
# Box plot
unempl <- cbind(all_ages_df$Unemployment_rate, recent_grad_df$Unemployment_rate, grad_df$Grad_unemployment_rate)
boxplot(unempl,names = c("All", "Recent Grad", "Grad Student"), ylab = "Unemployment Rate")
#Bar plot
unempl <- cbind(all_ages_df$Unemployment_rate, recent_grad_df$Unemployment_rate, grad_df$Grad_unemployment_rate)
barplot(unempl/nrow(unempl), names.arg = c("All", "Recent Grad", "Grad Student"), xlab = "Unemployment Rate", col = rainbow(nrow(unempl)))
# LINEAR MODEL for all ages
model1 <- lm(all_ages_df$Median ~ all_ages_df$Unemployment_rate)
summary(model1)
# Plot
ggplot(all_ages_df, aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# Residual plot
ggplot(model1, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model1))
qqline(resid(model1))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m1 <- boxcox(model1)
m1_df <- as.data.frame(m1)
(optimal_lambda <- m1_df[which.max(m1$y),1])
model2 <- lm(all_ages_df$Median^optimal_lambda ~ all_ages_df$Unemployment_rate)
summary(model2)
# Plot
ggplot(model2 , aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
library(tidyr)
library(dplyr)
library(psych)
library(stringr)
library(ggplot2)
library(MASS)
all_ages_df <-  read.csv(file ="https://raw.githubusercontent.com/fivethirtyeight/data/master/college-majors/all-ages.csv", header= TRUE)
names(all_ages_df)
all_ages_df_eng <- all_ages_df %>% filter(Major_category == "Engineering")
head(all_ages_df_eng)
grad_df <-  read.csv(file = "https://raw.githubusercontent.com/fivethirtyeight/data/master/college-majors/grad-students.csv", header= TRUE)
names(grad_df)
grad_df_eng <- grad_df %>% filter(Major_category == "Engineering")
head(grad_df_eng)
recent_grad_df <-  read.csv(file = "https://raw.githubusercontent.com/fivethirtyeight/data/master/college-majors/recent-grads.csv", header= TRUE)
names(recent_grad_df)
recent_grad_df_eng <- recent_grad_df %>% filter(Major_category == "Engineering")
head(recent_grad_df_eng)
summary(all_ages_df$Unemployment_rate)
summary(grad_df$Grad_unemployment_rate)
summary(recent_grad_df$Unemployment_rate)
# Box plot
unempl <- cbind(all_ages_df$Unemployment_rate, recent_grad_df$Unemployment_rate, grad_df$Grad_unemployment_rate)
boxplot(unempl,names = c("All", "Recent Grad", "Grad Student"), ylab = "Unemployment Rate")
#Bar plot
unempl <- cbind(all_ages_df$Unemployment_rate, recent_grad_df$Unemployment_rate, grad_df$Grad_unemployment_rate)
barplot(unempl/nrow(unempl), names.arg = c("All", "Recent Grad", "Grad Student"), xlab = "Unemployment Rate", col = rainbow(nrow(unempl)))
summary(all_ages_df$Median)
summary(grad_df$Grad_median)
summary(recent_grad_df$Median)
# Box plot
medsal <- cbind(all_ages_df$Median, recent_grad_df$Median, grad_df$Grad_median)
boxplot(medsal, names = c("All", "Recent Grad", "Grad Student"), ylab = "Median Salary USD")
#Barplot
income <- cbind(all_ages_df$Median, recent_grad_df$Median, grad_df$Grad_median)
barplot(income/nrow(income), names.arg = c("All", "Recent Grad", "Grad Student"), xlab = "income", col = rainbow(nrow(income)))
# For user-freindliness we'll pull major, number employed, number unemployed.
# for all ages
all_age_contin <- all_ages_df %>% dplyr::select(Major, Employed, Unemployed)
head(all_age_contin)
chisq.test(all_age_contin[,-1])
# for all grad
grd_st_contin <- grad_df %>% dplyr::select(Major, Grad_employed, Grad_unemployed)
head(grd_st_contin)
chisq.test(grd_st_contin[,-1])
#for all recent grad
rct_gr_contin <- recent_grad_df %>% dplyr::select(Major,Employed,Unemployed) %>% filter(Major != "MILITARY TECHNOLOGIES" )
head(rct_gr_contin)
chisq.test(rct_gr_contin[,-1])
# LINEAR MODEL for all ages
model1 <- lm(all_ages_df$Median ~ all_ages_df$Unemployment_rate)
summary(model1)
# Plot
ggplot(all_ages_df, aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# Residual plot
ggplot(model1, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model1))
qqline(resid(model1))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m1 <- boxcox(model1)
m1_df <- as.data.frame(m1)
(optimal_lambda <- m1_df[which.max(m1$y),1])
model2 <- lm(all_ages_df$Median^optimal_lambda ~ all_ages_df$Unemployment_rate)
summary(model2)
# Plot
ggplot(model2 , aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# model 1
model1 <- lm(all_ages_df$Median ~ all_ages_df$Unemployment_rate)
summary(model1)
# Plot
ggplot(all_ages_df, aes(x = Unemployment_rate, y = Median)) +geom_point(color = 'blue')+geom_smooth(method = "lm", formula = y~x)
# Residual plot
ggplot(model1, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model1))
qqline(resid(model1))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m1 <- boxcox(model1)
m1_df <- as.data.frame(m1)
(optimal_lambda <- m1_df[which.max(m1$y),1])
#model 2
model2 <- lm(all_ages_df$Median^optimal_lambda ~ all_ages_df$Unemployment_rate)
summary(model2)
#plot
hist(resid(model2))
# Residual plot
ggplot(model2, aes(.fitted, .resid)) + geom_point(color = "red", size=2) +labs(title = "Fitted Values vs Residuals") +labs(x = "Fitted Values") +labs(y = "Residuals")
# Normal plot
qqnorm(resid(model2))
qqline(resid(model2))
# An outlier is effecting our linear regression. Box Cox will be used to correct.
m2 <- boxcox(model2)
setwd("E:/github/MS/DATA606/Data606")
